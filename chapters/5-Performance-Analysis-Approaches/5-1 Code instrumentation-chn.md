---
typora-root-url: ..\..\img
---

## Code Instrumentation {#sec:secInstrumentation}

可能最早发明的进行性能分析的方法是代码检测。 它是一种在程序中插入额外代码以收集运行时信息的技术。 [@lst:CodeInstrumentation] 显示了在函数开头插入 `printf` 语句以计算调用此函数的次数的最简单示例。 我认为世界上的每个程序员都至少在某个时候做过一次。 当您需要有关程序执行的特定知识时，此方法可提供非常详细的信息。 代码检测使我们能够跟踪有关程序中每个变量的任何信息。

清单：代码检测

~~~~ {#lst:CodeInstrumentation .cpp}
int foo(int x) {
  printf("foo is called");
  // function body...
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

基于仪器的分析方法主要用于宏观层面，而不是微观（低）层面。在优化大量代码时，使用这种方法通常会产生最佳洞察力，因为您可以使用自上而下的方法（检测主函数，然后深入到其被调用者）来定位性能问题。虽然代码检测在小程序的情况下不是很有帮助，但它通过让开发人员观察应用程序的体系结构和流程来提供最大的价值和洞察力。这种技术对于使用不熟悉代码库的人特别有用。

还值得一提的是，代码检测在具有许多不同组件的复杂系统中大放异彩，这些组件会根据输入或随着时间的推移做出不同的反应。采样技术（在 [@sec:profiling] 中讨论）压缩了有价值的信息，不允许我们检测异常行为。例如，在游戏中，通常会有渲染线程、物理线程、动画线程等。检测这些大模块有助于合理快速地了解问题的根源是什么模块。有时，优化不仅是优化代码的问题，也是优化数据的问题。例如，由于未压缩的网格，渲染太慢，或者由于场景中的对象太多，物理太慢。

该技术大量用于实时场景，例如视频游戏和嵌入式开发。许多分析器[^3] 将仪器与本章讨论的其他技术（跟踪、采样）混为一谈。

虽然代码检测在许多情况下都很强大，但它并没有提供任何关于从操作系统或 CPU 角度执行代码的信息。例如，它无法为您提供有关进程被调度进出执行的频率（由操作系统知道）或发生了多少分支错误预测（由 CPU 知道）的信息。检测代码是应用程序的一部分，并具有与应用程序本身相同的权限。它在用户空间中运行并且无权访问内核。

但更重要的是，这种技术的缺点是每次需要检测新的东西时，比如另一个变量，都需要重新编译。这可能成为工程师的负担并增加分析时间。不幸的是，这并不是所有的缺点。由于通常您关心应用程序中的热路径，因此您正在检测驻留在代码的性能关键部分中的东西。在热门代码中插入检测代码可能很容易导致整体基准测试速度降低 2 倍 [^2]。最后，通过检测代码，您可以更改程序的行为，因此您可能看不到之前看到的相同效果。

所有这些都增加了实验之间的时间并消耗了更多的开发时间，这就是为什么现在工程师不经常手动检测他们的代码的原因。然而，自动代码检测仍然被编译器广泛使用。编译器能够自动检测整个程序并收集有关执行的有趣统计信息。最广为人知的用例是代码覆盖率分析和 Profile Guided Optimizations（参见 [@sec:secPGO]）。

在谈论仪器时，重要的是要提到二进制仪器技术。二进制检测背后的想法是相似的，但在已经构建的可执行文件上完成，而不是在源代码级别上完成。二进制检测有两种类型：静态（提前完成）和动态（在程序执行时按需插入的检测代码）。动态二进制检测的主要优点是它不需要重新编译和重新链接程序。此外，通过动态检测，可以将检测的数量限制在感兴趣的代码区域，而不是整个程序。

二进制检测在性能分析和调试中非常有用。最受欢迎的二进制检测工具之一是英特尔 [Pin](https://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool)[^1] 工具。 Pin 在发生有趣事件时拦截程序的执行，并从程序中的这一点开始生成新的检测代码。它允许收集各种运行时信息，例如：

* 指令计数和函数调用计数。
* 拦截函数调用和应用程序中任何指令的执行。
* 允许通过在区域开始时捕获内存和硬件寄存器状态来“记录和重放”程序区域。

与代码检测一样，二进制检测仅允许检测用户级代码并且可能非常慢。

[^1]: PIN - [https://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool](https://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool)
[^2]: Remember not to benchmark instrumented code, i.e., do not measure score and do analysis in the same run.
[^3]: A few examples: optick ([https://optick.dev](https://optick.dev)), tracy ([https://bitbucket.org/wolfpld/tracy](https://bitbucket.org/wolfpld/tracy)), superluminal ([https://superluminal.eu](https://superluminal.eu)).

