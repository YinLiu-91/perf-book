现代 CPU 每年都在获得越来越多的内核。截至 2019 年底，您可以购买拥有 100 多个逻辑核心的高端服务器处理器。这非常令人印象深刻，但这并不意味着我们不必再关心性能了。很多时候，应用程序性能可能不会随着更多的 CPU 内核而变得更好。典型的通用多线程应用程序的性能并不总是与我们分配给任务的 CPU 内核数量成线性关系。了解为什么会发生这种情况以及解决它的可能方法对于产品的未来增长至关重要。无法进行适当的性能分析和调优会导致大量性能和金钱损失，并且可能会扼杀产品。

根据 [@Leisersoneaam9744] 的说法，至少在短期内，大多数应用程序的大部分性能提升将来自软件堆栈。遗憾的是，默认情况下应用程序并没有获得最佳性能。文章 [@Leisersoneaam9744] 还提供了一个很好的示例，说明了可以在源代码级别进行的性能改进潜力。表@tbl:PlentyOfRoom 总结了将两个 4096×4096 矩阵相乘的程序的性能工程加速。应用多项优化的最终结果是程序运行速度提高了 60,000 倍以上。提供此示例的原因不是要选择 Python 或 Java（它们是很棒的语言），而是要打破软件默认具有“足够好”性能的信念。

-----------------------------------------------------------
版本实现绝对相对
                           加速加速

-------- -------------- -------- --------
   1 蟒蛇 1 —

   2 Java 11 10.8

   3 C 47 4.4

   4 并联回路 366 7.8

   5 平行除法 6,727 18.4
            并征服

   6 加 23,224 3.5
           矢量化

   7 加 AVX 62,806 2.7
           内在函数

-------------------------------------------------- ------------

表：性能工程带来的加速 将两个 4096×4096 矩阵相乘的程序在双插槽 Intel Xeon E5-2666 v3 系统上运行，总内存为 60 GB。来自 [@Leisersoneaam9744]。 {#tbl:PlentyOfRoom}

以下是阻止系统默认实现最佳性能的一些最重要的因素：

1. **CPU 限制**。很想问：“*为什么硬件不能解决我们所有的问题？”* 现代 CPU 以令人难以置信的速度执行指令，并且每一代都在变得更好。但是，如果用于执行工作的指令不是最优的甚至是多余的，它们仍然无法做很多事情。处理器不能神奇地将次优代码转换为性能更好的代码。例如，如果我们使用 [BubbleSort](https://en.wikipedia.org/wiki/Bubble_sort)[^1] 算法实现排序例程，CPU 将不会尝试识别它并使用更好的替代方案，例如，[快速排序](https://en.wikipedia.org/wiki/Quicksort)[^2]。它会盲目地执行它被告知要做的任何事情。
2. **编译器限制**。 *“但这不是编译器应该做的吗？为什么编译器不能解决我们所有的问题？”* 的确，如今的编译器非常聪明，但仍然可以生成次优代码。编译器非常擅长消除冗余工作，但在做出更复杂的决策（如函数内联、循环展开等）时，它们可能无法生成最好的代码。例如，对于编译器是否应该始终将函数内联到调用它的位置的问题，没有二进制“是”或“否”的答案。它通常取决于编译器应考虑的许多因素。通常，编译器依赖于复杂的成本模型和启发式方法，这可能不适用于所有可能的场景。此外，编译器无法执行优化，除非他们确定这样做是安全的，并且不会影响生成的机器代码的正确性。编译器开发人员可能很难确保特定优化将在所有可能的情况下生成正确的代码，因此他们通常必须保守并避免进行一些优化[^7]。最后，编译器通常不会转换程序使用的数据结构，这在性能方面也很重要。
3. **算法复杂性分析限制**。开发人员经常过度痴迷于算法的复杂性分析，这导致他们选择具有最佳算法复杂度的流行算法，即使它对于给定问题可能不是最有效的。考虑两种排序算法 [InsertionSort](https://en.wikipedia.org/wiki/Insertion_sort)[^3] 和 [QuickSort](https://en.wikipedia.org/wiki/Quicksort)，
